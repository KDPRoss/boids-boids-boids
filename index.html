<html>
  <head>
    <style>
      #graphicsCanvas {
        border: 2px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="graphicsCanvas" width="800" height="600"/>
    <script>
      const minX = 0;
      const maxX = 800;
      const minY = 0;
      const maxY = 600;

      const canvas = document.getElementById('graphicsCanvas');
      const ctx = canvas.getContext('2d');
      
      const randBetw = (min, max) => Math.random() * (max - min) + min;
      const randSign = () => Math.random() < 0.5 ? 1 : -1;
      const scaleFactor = Math.floor((maxX - minX) / 200);
      const numObjs = 25;
      let objs =
        new Array(numObjs).fill(undefined).map(() => ({
          x: randBetw(minX, maxX),
          y: randBetw(minY, maxY),
          dx: randBetw(0.1, scaleFactor) * randSign(),
          dy: randBetw(0.1, scaleFactor) * randSign(),
        }));

      const black = '#000000';
      const red = '#ff0000';

      const line = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      };

      const norm = (x, y) => Math.sqrt(x ** 2 + y ** 2);

      const objSize = 3;
      const sightRadius = 150;
      const numNeighbours = 10;
      const renderObj = ({
        x,
        y,
        dx,
        dy,
        nearNeighbours,
      }) => {
        ctx.fillRect(x, y, objSize, objSize);

        ctx.strokeStyle = black;
        nearNeighbours.forEach((n) => {
          line(x, y, n.x, n.y);
        });
      }

      const bound = (val, min, max) => {
        if (val < min) {
          return max - val;
        }
        if (val > max) {
          return val - max;
        }
        return val;
      }

      const update = () => {
        objs =
          objs.map((obj) => {
            const xNew = bound(obj.x + obj.dx, minX, maxX);
            const yNew = bound(obj.y + obj.dy, minY, maxY);

            const byDist =
              objs
                .map(({ x, y }) => {
                  const dist = norm(xNew - x, yNew - y);
                  return {
                    x,
                    y,
                    dist,
                  };
                })
                .filter(({ dist }) => dist <= sightRadius)
                .sort(({ dist: distA }, { dist: distB }) => distA - distB);

            // Remove self.
            byDist.shift();

            const n = Math.min(numNeighbours, byDist.length);
            const nearNeighbours = [];

            for (let i = 0; i < n; i ++) {
              nearNeighbours.push(byDist[i]);
            }

            return {
              ...obj,
              nearNeighbours,
              x: bound(obj.x + obj.dx, minX, maxX),
              y: bound(obj.y + obj.dy, minY, maxY),
            };
        });
      };

      const render = () => {
        ctx.clearRect(minX, minY, maxX, maxY);
        objs.forEach(renderObj); 
      };

      const tick = () => {
        update();
        render();
      };

      setInterval(tick, 20);
    
    </script>
  </body>
</html>
